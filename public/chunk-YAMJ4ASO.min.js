import{a as _,b as O,d as k,e as y,f as F,g as G,h as U,i as T,k as A,l as $,m as H,n as M}from"./chunk-3RELVOUY.min.js";import{b as R}from"./chunk-DALFUHAB.min.js";import{a as L,d as D,f as x,j as J,k as P}from"./chunk-EKFGDCJ4.min.js";import{Ga as n,Ja as E,h as B,jb as N}from"./chunk-YICCS3KT.min.js";function m(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:Y(e),edges:Z(e)};return x(e.graph())||(t.value=L(e.graph())),t}function Y(e){return D(e.nodes(),(function(t){var n=e.node(t),r=e.parent(t),i={v:t};return x(n)||(i.value=n),x(r)||(i.parent=r),i}))}function Z(e){return D(e.edges(),(function(t){var n=e.edge(t),r={v:t.v,w:t.w};return x(t.name)||(r.name=t.name),x(n)||(r.value=n),r}))}var f={},g={},V={},tt=()=>{g={},V={},f={}},S=(e,t)=>(n.trace("In isDecendant",t," ",e," = ",g[t].includes(e)),!!g[t].includes(e)),et=(e,t)=>(n.info("Decendants of ",t," is ",g[t]),n.info("Edge is ",e),e.v!==t&&e.w!==t&&(g[t]?g[t].includes(e.v)||S(e.v,t)||S(e.w,t)||g[t].includes(e.w):(n.debug("Tilt, ",t,",not in decendants"),!1))),j=(e,t,r,i)=>{n.warn("Copying children of ",e,"root",i,"data",t.node(e),i);let a=t.children(e)||[];e!==i&&a.push(e),n.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach((a=>{if(t.children(a).length>0)j(a,t,r,i);else{let d=t.node(a);n.info("cp ",a," to ",i," with parent ",e),r.setNode(a,d),i!==t.parent(a)&&(n.warn("Setting parent",a,t.parent(a)),r.setParent(a,t.parent(a))),e!==i&&a!==e?(n.debug("Setting parent",a,e),r.setParent(a,e)):(n.info("In copy ",e,"root",i,"data",t.node(e),i),n.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==i,"node!==clusterId",a!==e));let o=t.edges(a);n.debug("Copying Edges",o),o.forEach((a=>{n.info("Edge",a);let d=t.edge(a.v,a.w,a.name);n.info("Edge data",d,i);try{et(a,i)?(n.info("Copying as ",a.v,a.w,d,a.name),r.setEdge(a.v,a.w,d,a.name),n.info("newGraph edges ",r.edges(),r.edge(r.edges()[0]))):n.info("Skipping copy of edge ",a.v,"--\x3e",a.w," rootId: ",i," clusterId:",e)}catch(o){n.error(o)}}))}n.debug("Removing node",a),t.removeNode(a)}))},W=(e,t)=>{let n=t.children(e),r=[...n];for(let i of n)V[i]=e,r=[...r,...W(i,t)];return r},p=(e,t)=>{n.trace("Searching",e);let r=t.children(e);if(n.trace("Searching children of id ",e,r),r.length<1)return n.trace("This is a valid node",e),e;for(let i of r){let r=p(i,t);if(r)return n.trace("Found replacement for",e," => ",r),r}},X=e=>f[e]&&f[e].externalConnections&&f[e]?f[e].id:e,it=(e,t)=>{!e||t>10?n.debug("Opting out, no graph "):(n.debug("Opting in, graph "),e.nodes().forEach((function(t){e.children(t).length>0&&(n.warn("Cluster identified",t," Replacement id in edges: ",p(t,e)),g[t]=W(t,e),f[t]={id:p(t,e),clusterData:e.node(t)})})),e.nodes().forEach((function(t){let r=e.children(t),i=e.edges();r.length>0?(n.debug("Cluster identified",t,g),i.forEach((e=>{if(e.v!==t&&e.w!==t){S(e.v,t)^S(e.w,t)&&(n.warn("Edge: ",e," leaves cluster ",t),n.warn("Decendants of XXX ",t,": ",g[t]),f[t].externalConnections=!0)}}))):n.debug("Not a cluster ",t,g)})),e.edges().forEach((function(t){let r=e.edge(t);n.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),n.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let i=t.v,a=t.w;if(n.warn("Fix XXX",f,"ids:",t.v,t.w,"Translating: ",f[t.v]," --- ",f[t.w]),f[t.v]&&f[t.w]&&f[t.v]===f[t.w]){n.warn("Fixing and trixing link to self - removing XXX",t.v,t.w,t.name),n.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),i=X(t.v),a=X(t.w),e.removeEdge(t.v,t.w,t.name);let d=t.w+"---"+t.v;e.setNode(d,{domId:d,id:d,labelStyle:"",labelText:r.label,padding:0,shape:"labelRect",style:""});let o=structuredClone(r),s=structuredClone(r);o.label="",o.arrowTypeEnd="none",s.label="",o.fromCluster=t.v,s.toCluster=t.v,e.setEdge(i,d,o,t.name+"-cyclic-special"),e.setEdge(d,a,s,t.name+"-cyclic-special")}else(f[t.v]||f[t.w])&&(n.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),i=X(t.v),a=X(t.w),e.removeEdge(t.v,t.w,t.name),i!==t.v&&(r.fromCluster=t.v),a!==t.w&&(r.toCluster=t.w),n.warn("Fix Replacing with XXX",i,a,t.name),e.setEdge(i,a,r,t.name))})),n.warn("Adjusted Graph",m(e)),q(e,0),n.trace(f))},q=(e,t)=>{if(n.warn("extractor - ",t,m(e),e.children("D")),t>10)return void n.error("Bailing out");let r=e.nodes(),i=!1;for(let n of r){let t=e.children(n);i=i||t.length>0}if(i){n.debug("Nodes = ",r,t);for(let i of r)if(n.debug("Extracting node",i,f,f[i]&&!f[i].externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",t),f[i])if(!f[i].externalConnections&&e.children(i)&&e.children(i).length>0){n.warn("Cluster without external connections, without a parent and with children",i,t);let r="TB"===e.graph().rankdir?"LR":"TB";f[i]&&f[i].clusterData&&f[i].clusterData.dir&&(r=f[i].clusterData.dir,n.warn("Fixing dir",f[i].clusterData.dir,r));let a=new J({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel((function(){return{}}));n.warn("Old graph before copy",m(e)),j(i,e,a,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:f[i].clusterData,labelText:f[i].labelText,graph:a}),n.warn("New graph after copy node: (",i,")",m(a)),n.debug("Old graph after copy",m(e))}else n.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!f[i].externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),t),n.debug(f);else n.debug("Not a cluster",i,t);r=e.nodes(),n.warn("New list of nodes",r);for(let i of r){let r=e.node(i);n.warn(" Now next level",i,r),r.clusterNode&&q(r.graph,t+1)}}else n.debug("Done, no node has children",e.nodes())},z=(e,t)=>{if(0===t.length)return[];let n=Object.assign(t);return t.forEach((t=>{let r=e.children(t),i=z(e,r);n=[...n,...i]})),n},nt=e=>z(e,e.children()),st=(e,t)=>{n.info("Creating subgraph rect for ",t.id,t);let r=e.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),i=r.insert("rect",":first-child"),a=E(N().flowchart.htmlLabels),d=r.insert("g").attr("class","cluster-label"),o="markdown"===t.labelType?R(d,t.labelText,{style:t.labelStyle,useHtmlLabels:a}):d.node().appendChild(O(t.labelText,t.labelStyle,void 0,!0)),s=o.getBBox();if(E(N().flowchart.htmlLabels)){let e=o.children[0],t=B(o);s=e.getBoundingClientRect(),t.attr("width",s.width),t.attr("height",s.height)}let l=0*t.padding,h=l/2,g=t.width<=s.width+l?s.width+l:t.width;t.width<=s.width+l?t.diff=(s.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,n.trace("Data ",t,JSON.stringify(t)),i.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-g/2).attr("y",t.y-t.height/2-h).attr("width",g).attr("height",t.height+l),a?d.attr("transform","translate("+(t.x-s.width/2)+", "+(t.y-t.height/2)+")"):d.attr("transform","translate("+t.x+", "+(t.y-t.height/2)+")");let f=i.node().getBBox();return t.width=f.width,t.height=f.height,t.intersect=function(e){return y(t,e)},r},rt=(e,t)=>{let n=e.insert("g").attr("class","note-cluster").attr("id",t.id),r=n.insert("rect",":first-child"),i=0*t.padding,a=i/2;r.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2-a).attr("width",t.width+i).attr("height",t.height+i).attr("fill","none");let d=r.node().getBBox();return t.width=d.width,t.height=d.height,t.intersect=function(e){return y(t,e)},n},at=(e,t)=>{let n=e.insert("g").attr("class",t.classes).attr("id",t.id),r=n.insert("rect",":first-child"),i=n.insert("g").attr("class","cluster-label"),a=n.append("rect"),d=i.node().appendChild(O(t.labelText,t.labelStyle,void 0,!0)),o=d.getBBox();if(E(N().flowchart.htmlLabels)){let e=d.children[0],t=B(d);o=e.getBoundingClientRect(),t.attr("width",o.width),t.attr("height",o.height)}o=d.getBBox();let s=0*t.padding,l=s/2,h=t.width<=o.width+t.padding?o.width+t.padding:t.width;t.width<=o.width+t.padding?t.diff=(o.width+0*t.padding-t.width)/2:t.diff=-t.padding/2,r.attr("class","outer").attr("x",t.x-h/2-l).attr("y",t.y-t.height/2-l).attr("width",h+s).attr("height",t.height+s),a.attr("class","inner").attr("x",t.x-h/2-l).attr("y",t.y-t.height/2-l+o.height-1).attr("width",h+s).attr("height",t.height+s-o.height-3),i.attr("transform","translate("+(t.x-o.width/2)+", "+(t.y-t.height/2-t.padding/3+(E(N().flowchart.htmlLabels)?5:3))+")");let g=r.node().getBBox();return t.height=g.height,t.intersect=function(e){return y(t,e)},n},ct=(e,t)=>{let n=e.insert("g").attr("class",t.classes).attr("id",t.id),r=n.insert("rect",":first-child"),i=0*t.padding,a=i/2;r.attr("class","divider").attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2).attr("width",t.width+i).attr("height",t.height+i);let d=r.node().getBBox();return t.width=d.width,t.height=d.height,t.diff=-t.padding/2,t.intersect=function(e){return y(t,e)},n},ot={rect:st,roundedWithTitle:at,noteGroup:rt,divider:ct},K={},lt=(e,t)=>{n.trace("Inserting cluster");let r=t.shape||"rect";K[t.id]=ot[r](e,t)},ft=()=>{K={}},Q=async(e,t,r,i,a)=>{n.info("Graph in recursive render: XXX",m(t),a);let d=t.graph().rankdir;n.trace("Dir in recursive render - dir:",d);let o=e.insert("g").attr("class","root");t.nodes()?n.info("Recursive render XXX",t.nodes()):n.info("No nodes found for",t),t.edges().length>0&&n.trace("Recursive edges",t.edge(t.edges()[0]));let s=o.insert("g").attr("class","clusters"),l=o.insert("g").attr("class","edgePaths"),h=o.insert("g").attr("class","edgeLabels"),g=o.insert("g").attr("class","nodes");await Promise.all(t.nodes().map((async function(e){let o=t.node(e);if(void 0!==a){let r=JSON.parse(JSON.stringify(a.clusterData));n.info("Setting data for cluster XXX (",e,") ",r,a),t.setNode(a.id,r),t.parent(e)||(n.trace("Setting parent",e,a.id),t.setParent(e,a.id,r))}if(n.info("(Insert) Node XXX"+e+": "+JSON.stringify(t.node(e))),o&&o.clusterNode){n.info("Cluster identified",e,o.width,t.node(e));let a=await Q(g,o.graph,r,i,t.node(e)),d=a.elem;k(o,d),o.diff=a.diff||0,n.info("Node bounds (abc123)",e,o,o.width,o.x,o.y),G(d,o),n.warn("Recursive render complete ",d,o)}else t.children(e).length>0?(n.info("Cluster - the non recursive path XXX",e,o.id,o,t),n.info(p(o.id,t)),f[o.id]={id:p(o.id,t),node:o}):(n.info("Node - the non recursive path",e,o.id,o),await F(g,t.node(e),d))}))),t.edges().forEach((function(e){let r=t.edge(e.v,e.w,e.name);n.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),n.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(t.edge(e))),n.info("Fix",f,"ids:",e.v,e.w,"Translateing: ",f[e.v],f[e.w]),$(h,r)})),t.edges().forEach((function(e){n.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e))})),n.info("#############################################"),n.info("###                Layout                 ###"),n.info("#############################################"),n.info(t),P(t),n.info("Graph after layout:",m(t));let c=0;return nt(t).forEach((function(e){let r=t.node(e);n.info("Position "+e+": "+JSON.stringify(t.node(e))),n.info("Position "+e+": ("+r.x,","+r.y,") width: ",r.width," height: ",r.height),r&&r.clusterNode?T(r):t.children(e).length>0?(lt(s,r),f[r.id].node=r):T(r)})),t.edges().forEach((function(e){let a=t.edge(e);n.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(a),a);let d=M(l,e,a,f,r,t,i);H(a,d)})),t.nodes().forEach((function(e){let r=t.node(e);n.info(e,r.type,r.diff),"group"===r.type&&(c=r.diff)})),{elem:o,diff:c}},yt=async(e,t,r,i,a)=>{_(e,r,i,a),U(),A(),ft(),tt(),n.warn("Graph at first:",JSON.stringify(m(t))),it(t),n.warn("Graph after:",JSON.stringify(m(t))),await Q(e,t,i,a)};export{yt as a};